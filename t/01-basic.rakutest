use Test;
use MoarVM::Profile;

plan 5 * 104 + 12;

my constant $times = 1000000;

my sub test-object-sanity($object, $type) is test-assertion {
    subtest "Testing sanity of $type.^name() object" => {
        plan 6;

        isa-ok $object,$type;
        isa-ok $object.gist, Str;
        isa-ok $object.table, Str;
        isa-ok $object.method-names, List;
        isa-ok $object.columns, Str;
        isa-ok $object.select, Str;
    }
}

#- profile ---------------------------------------------------------------------
my $foo-raku := $*PROGRAM.sibling("foo.raku");
for
  'code', qq/sub foo(\$a) \{ \$a * \$a }\nfoo(\$_) for ^$times/, '-e',
  'io',   $foo-raku,  ~$foo-raku,
  'path', ~$foo-raku, ~$foo-raku,
  'SQL',  $*PROGRAM.sibling("foo.sql"),   '-e',
  'db',   $*PROGRAM.sibling("foo.db"),    '-e'
-> $source, $target, $file {
    diag "Testing profile from $source";

    my $profile := MoarVM::Profile.new($target);
    isa-ok $profile, MoarVM::Profile;
    isa-ok $profile.gist, Str;

    my $overview := $profile.overview;
    test-object-sanity $overview, MoarVM::Profile::Overview;

    ok $overview.total-time,     'some time was spent indeed';
    ok $overview.spesh-time,     'some time was spent in spesh indeed';
    ok $overview.thread-id        == 1, 'and only one thread active';
    ok $overview.parent-thread-id == 0, 'without a parent';
    ok $overview.first-entry-time == 0, 'only one profile';

#- files -----------------------------------------------------------------------
    my $file-names := $profile.files;
    isa-ok $file-names, List;
    ok +$file-names, 'quite a few files overall';
    is-deeply ([lt] $file-names.map(*.fc)), True,
      'filenames in ascending order';

    my $routine-names := $profile.names;
    isa-ok $routine-names, List;
    ok +$routine-names, 'quite a few files overall';
    is-deeply ([lt] $routine-names.map(*.fc)), True,
      'routine names in ascending order';

    my $user-files := $profile.user-files;
    isa-ok $user-files, List;
    ok $user-files == 1,        'only one user file';
    is $user-files.head, $file, 'the place with the code';
    is-deeply ([lt] $user-files), True, 'user filenames in ascending order';

    my $user-names := $profile.user-names;
    isa-ok $user-names, List;
    ok +$user-names,            'more than one user-code routine';
    is $user-names.tail, 'foo', 'the only named routine';
    is-deeply ([lt] $user-names), True, 'user routine names in ascending order';

#- deallocations ---------------------------------------------------------------
    my $deallocations := $profile.deallocations;
    isa-ok $deallocations, List;
    ok +$deallocations, 'quite a few deallocations seen';

    my $deallocation := $deallocations.head;
    test-object-sanity $deallocation, MoarVM::Profile::Deallocation;

    ok $deallocation.gc-seq-num == 1,   'from the first garbage collection';
    ok $deallocation.gc-thread-id == 1, 'only one thread';
    ok $deallocation.type-id,           'has a type ID';

#- routine ---------------------------------------------------------------------
    my $routines := $profile.routines(:name<foo>, :$file, :line(1));
    isa-ok $routines, List;
    ok $routines == 1, 'only one routine by this name and file';

    my $routine := $routines.head;
    test-object-sanity $routine, MoarVM::Profile::Routine;

    is-deeply $routine.name, 'foo', 'sub name is ok';
    is-deeply $routine.file, $file, 'file name is ok';
    is-deeply $routine.line, 1,     'line number is ok';

    is-deeply $routine.is-block, False, 'it is not a block';
    is-deeply $routine.is-core,  False, 'it is not from Rakudo core';
    is-deeply $routine.is-user,  True,  'it is a user supplied routine';

    $overview := $routine.overview;
    test-object-sanity $overview, MoarVM::Profile::RoutineOverview;

    my $entries         := $overview.entries;
    my $inclusive-time  := $overview.inclusive-time;
    my $exclusive-time  := $overview.exclusive-time;
    my $spesh-entries   := $overview.spesh-entries;
    my $inlined-entries := $overview.inlined-entries;
    my $site-count      := $overview.site-count;

    ok $entries        == $times,          'seen all calls made';
    ok $spesh-entries   < $entries,        'fewer spesh entries';
    todo("$inlined-entries < $spesh-entries on Intel???") unless $spesh-entries;
    ok $inlined-entries < $spesh-entries,  'fewer inlined entries';
    ok $exclusive-time  < $inclusive-time, 'exclusive time is less';

#- calls -----------------------------------------------------------------------
    my $calls := $routine.calls;
    isa-ok $calls, List;
    ok $calls == $site-count, 'only one call-site';

    my $call := $calls.head;
    test-object-sanity $call, MoarVM::Profile::Call;

    ok $call.first-entry-time > 0,                'valid entry time';
    ok $call.parent-id        < $call.id,         'parent was earlier';
    ok $call.id         < $call.highest-child-id, 'children are later';
    ok $call.entries         == $entries,         'entries matches';
    ok $call.spesh-entries   == $spesh-entries,   'spesh-entries matches';
    ok $call.inlined-entries == $inlined-entries, 'inlined-entries matches';
    ok $call.inclusive-time  == $inclusive-time,  'inclusive time matches';
    ok $call.exclusive-time  == $exclusive-time,  'exclusive time matches';

    my $parent := $call.parent;
    ok $parent.id == $call.parent-id, 'parent ID appears correct';
    test-object-sanity $parent, MoarVM::Profile::Call;

    my $ancestry := $call.ancestry;
    isa-ok $ancestry, List;
    ok $ancestry.are(MoarVM::Profile::Call), 'ancestry consists of calls';
    ok $ancestry.head.id == $profile.calls.head.id, 'always wind up at first';

    my $allocations := $call.allocations;
    isa-ok $allocations, List;
    ok +$allocations, 'must have at least one allocation';

    my $allocation := $allocations.head;
    test-object-sanity $allocation, MoarVM::Profile::Allocation;

    ok $allocation.count + $allocation.replaced == $times,
      'the number of allocations (real and replaced) checks out';
    is $profile.types[$allocation.type-id].name, 'Scalar',
      'is the type of allocation correct';

#- calls-overview --------------------------------------------------------------
    my $cs-overview := $profile.calls-overview;
    test-object-sanity $cs-overview, MoarVM::Profile::CallsOverview;

    $entries         := $cs-overview.entries-total;
    $spesh-entries   := $cs-overview.spesh-entries-total;
    $inlined-entries := $cs-overview.inlined-entries-total;
    ok $spesh-entries < $entries, 'spesh entries < total entries';
    todo("$inlined-entries < $spesh-entries on Intel???") unless $spesh-entries;
    ok $inlined-entries < $spesh-entries, 'inlined entries < spesh entries';
    ok $cs-overview.osr-total == 1, 'only one on stack replacement done';

#- gc-overview -----------------------------------------------------------------
    my $gc-overview := $profile.gc-overview;
    test-object-sanity $gc-overview, MoarVM::Profile::GCOverview;

# Assuming there have not been any full garbage collections done
    ok $gc-overview.min-minor-time < $gc-overview.avg-minor-time, 'min time ok';
    ok $gc-overview.avg-minor-time < $gc-overview.max-minor-time, 'avg time ok';
    ok $gc-overview.max-minor-time < $gc-overview.total-minor,    'max time ok';
    ok $gc-overview.min-major-time == 0, 'min major time ok';
    ok $gc-overview.avg-major-time == 0, 'avg major time ok';
    ok $gc-overview.max-major-time == 0, 'max major time ok';
    ok $gc-overview.total-major    == 0, 'total major time ok';

#- gcs -------------------------------------------------------------------------
    my $gcs := $profile.gcs;
    isa-ok $gcs, List;

    ok +$gcs, 'there should have been some garbage collections';
    ok ( [<] $gcs.map(*.sequence-num)), 'sequence numbers advance';
    ok ( [<] $gcs.map(*.start-time)),   'start-time advances';
    ok ([==] $gcs.map(*.thread-id)),    'all with the same thread';

    my $gc := $gcs.head;
    test-object-sanity($gc, MoarVM::Profile::GC);

    ok $gc.responsible  == 1, 'it was a responsible garbage collection';
    ok $gc.sequence-num == 1, 'first garbage collection';
    ok $gc.thread-id    == 1, 'only have one thread';

#- types -----------------------------------------------------------------------
    my $types := $profile.types(:name<Scalar>);
    isa-ok $types, List;
    ok $types == 1, 'only one type by this name';

    my $type := $types.head;
    test-object-sanity $type, MoarVM::Profile::Type;
    is $type.name, 'Scalar', 'name is ok';

    my $extra-info := $type.extra-info;
    isa-ok $extra-info, Map;

    ok $extra-info<managed_size>:exists, 'managed_size appears to be there';
    ok $extra-info<repr>:exists,         'repr appears to be there';
    ok $extra-info<scdesc>:exists,       'scdesc appears to be there';
    ok $extra-info<type>:exists,         'type appears to be there';
    ok $extra-info<typename>:exists,     'typename appears to be there';

    my $type-links := $type.type-links;
    isa-ok $type-links, Map;

    $allocations := $type.allocations;
    isa-ok $allocations, List;
    ok +$allocations, 'seen allocations for this type';

    $allocation := $allocations.head;
    test-object-sanity $allocation, MoarVM::Profile::Allocation;

    ok $allocation.call-id, 'there appears to be a call ID';
    ok $allocation.type-id == $type.id, 'with the correct type ID';
    ok $allocation.spesh < $times, 'with an expected number of spesh count';
    ok $allocation.count < $times, 'with an expected count';

#- spesh-overview --------------------------------------------------------------
    my $spesh-overviews := $profile.spesh-overviews;
    isa-ok $spesh-overviews, List;

    my $sp-overview := $spesh-overviews.head;
    test-object-sanity $sp-overview, MoarVM::Profile::SpeshOverview;

    # not sure what to reliably test here
}

my $profile := MoarVM::Profile.new($*PROGRAM.sibling("foo.db"));
is $profile.routines.head.name, '(block)', 'an unnamed routine';
dies-ok { $profile.query("not a valid SQL query") }, 'a wrong SQL query dies';
dies-ok { $profile.routines(:foo<bar>) }, 'unhandled named arg in routines';
dies-ok { $profile.types(:foo<bar>) },    'unhandled named arg in types';

for
  {:name<foo>,},
  {:name<foo>, :file<-e>},
  {:file<-e>,},
  {:file<-e>, :line(1)}
{
    my $routines := $profile.routines(|$_);
    isa-ok $routines, List;
    ok +$routines, "$_.gist() produced $routines.elems() entries";
}

# vim: expandtab shiftwidth=4
